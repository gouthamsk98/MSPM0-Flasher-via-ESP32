var m=Object.defineProperty;var b=(o,r,e)=>r in o?m(o,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[r]=e;var l=(o,r,e)=>b(o,typeof r!="symbol"?r+"":r,e);(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))t(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const a of n.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&t(a)}).observe(document,{childList:!0,subtree:!0});function e(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function t(i){if(i.ep)return;i.ep=!0;const n=e(i);fetch(i.href,n)}})();class A{constructor(r,e=!0,t=!1){l(this,"slipReaderEnabled",!1);l(this,"leftOver",new Uint8Array(0));l(this,"baudrate",115200);l(this,"traceLog","");l(this,"lastTraceTime",Date.now());l(this,"reader");l(this,"checksum",function(r){let e,t=239;for(e=0;e<r.length;e++)t^=r[e];return t});this.device=r,this.tracing=e,this.slipReaderEnabled=t,this.getInfo()}getInfo(){const r=this.device.getInfo();return console.log("Product info",r),r.usbVendorId&&r.usbProductId}async sleep(r){return new Promise(e=>setTimeout(e,r))}async waitForUnlock(r){for(;this.device.readable&&this.device.readable.locked||this.device.writable&&this.device.writable.locked;)await this.sleep(r)}async connect(r=115200){try{await this.device.open({baudRate:r,bufferSize:1024*10}),this.baudrate=r,this.leftOver=new Uint8Array(0),console.log("Connected to device")}catch(e){console.error("Error in connect",e)}}async disconnect(){var r,e;(r=this.device.readable)!=null&&r.locked&&await((e=this.reader)==null?void 0:e.cancel()),await this.waitForUnlock(400),this.reader=void 0,await this.device.close()}trace(r){const i=`${`TRACE ${(Date.now()-this.lastTraceTime).toFixed(3)}`} ${r}`;console.log(i),this.traceLog+=i+`
`}hexify(r){return Array.from(r).map(e=>e.toString(16).padStart(2,"0")).join("").padEnd(16," ")}hexConvert(r,e=!0){if(e&&r.length>16){let t="",i=r;for(;i.length>0;){const n=i.slice(0,16),a=String.fromCharCode(...n).split("").map(s=>s===" "||s>=" "&&s<="~"&&s!=="  "?s:".").join("");i=i.slice(16),t+=`
    ${this.hexify(n.slice(0,8))} ${this.hexify(n.slice(8))} | ${a}`}return t}else return this.hexify(r)}async returnTrace(){try{await navigator.clipboard.writeText(this.traceLog),console.log("Text copied to clipboard!")}catch(r){console.error("Failed to copy text:",r)}}_appendBuffer(r,e){const t=new Uint8Array(r.byteLength+e.byteLength);return t.set(new Uint8Array(r),0),t.set(new Uint8Array(e),r.byteLength),t.buffer}slipWriter(r){const e=new Array;e.push(192);for(let t=0;t<r.length;t++)r[t]===219?e.push(219,221):r[t]===192?e.push(219,220):e.push(r[t]);return e.push(192),new Uint8Array(e)}async writeChunk(r,e){let t=0;if(this.device.writable){const i=this.device.writable.getWriter();for(;t<r.length;){const n=r.slice(t,t+e);await i.write(n),console.log("Write chunk",n),t+=e}i.releaseLock()}}async write(r){const e=this.slipReaderEnabled?this.slipWriter(r):r;if(this.device.writable){const t=this.device.writable.getWriter();this.tracing&&(console.log("Write bytes"),this.trace(`Write ${e.length} bytes: ${this.hexConvert(e)}`)),await t.write(e),console.log("Write bytes",e),t.releaseLock()}}slipReader(r){let e=0,t=0,i=0,n="init";for(;e<r.length;){if(n==="init"&&r[e]==192){t=e+1,n="valid_data",e++;continue}if(n==="valid_data"&&r[e]==192){i=e-1,n="packet_complete";break}e++}if(n!=="packet_complete")return this.leftOver=r,new Uint8Array(0);this.leftOver=r.slice(i+2);const a=new Uint8Array(i-t+1);let s=0;for(e=t;e<=i;e++,s++){if(r[e]===219&&r[e+1]===220){a[s]=192,e++;continue}if(r[e]===219&&r[e+1]===221){a[s]=219,e++;continue}a[s]=r[e]}return a.slice(0,s)}async read(r=0,e=12){let t,i=this.leftOver;if(this.leftOver=new Uint8Array(0),this.slipReaderEnabled){const n=this.slipReader(i);if(n.length>0)return n;i=this.leftOver,this.leftOver=new Uint8Array(0)}if(this.device.readable==null)return this.leftOver;this.reader=this.device.readable.getReader();try{r>0&&(t=setTimeout(()=>{this.reader&&this.reader.cancel()},r));do{if(!this.reader)throw new Error("Reader is undefined");const{value:n,done:a}=await this.reader.read();if(a&&(this.leftOver=i,console.log("Timeout")),!n)break;i=new Uint8Array(this._appendBuffer(i.buffer,n.buffer))}while(i.length<e)}finally{if(r>0&&clearTimeout(t),!this.reader)throw new Error("Reader is undefined");this.reader.releaseLock()}if(this.tracing&&(console.log("Read bytes"),this.trace(`Read ${i.length} bytes: ${this.hexConvert(i)}`)),this.slipReaderEnabled){const n=this.slipReader(i);return this.tracing&&(console.log("Slip reader results"),this.trace(`Read ${n.length} bytes: ${this.hexConvert(n)}`)),n}return i}async rawRead(r=0){if(this.leftOver.length!=0){const t=this.leftOver;return this.leftOver=new Uint8Array(0),t}if(!this.device.readable)return this.leftOver;this.reader=this.device.readable.getReader();let e;try{if(r>0&&(e=setTimeout(()=>{this.reader&&this.reader.cancel()},r)),!this.reader)throw new Error("Reader is undefined");const{value:t,done:i}=await this.reader.read();return i?t||new Uint8Array(0):(this.tracing&&(console.log("Raw Read bytes"),this.trace(`Read ${t.length} bytes: ${this.hexConvert(t)}`)),t)}finally{if(r>0&&clearTimeout(e),!this.reader)throw new Error("Reader is undefined");this.reader.releaseLock()}}checkSum(r,e){let t=0;console.log("buf",e);for(let i=2;i<e-1;i++)t+=r[i];return t=t&255,t=~t&255,t}frameToSerial(r,e,t,i){const n=i+9,a=i+2,s=new Uint8Array(n);return s[0]=249,s[1]=255,s[2]=a>>24&255,s[3]=a>>16&255,s[4]=a>>8&255,s[5]=a&255,s[6]=r,s[7]=e,s.set(t,8),s[s.length-1]=this.checkSum(s,s.length-1),s}dataFromSerial(r){const e=this.checkSum(r,r.length);return console.log("CKSM",e,r),r[0]!==249||r[1]!==245||r[r.length-1]!==e?(console.log("Invalid frame"),null):[r[7],r.subarray(8,r.length)]}}const d=class d extends A{constructor(e){super(e);l(this,"DEFAULT_BAUD",115200);l(this,"MAX_BUFF_LEN",64);l(this,"SETUP",!1);l(this,"BSL",!1);l(this,"CRC32_POLY",3988292384);l(this,"_crc32",4294967295);l(this,"START",1);l(this,"ERASE",2);l(this,"PAGE_ERASE",3);l(this,"WRITE",4);l(this,"READ",5);l(this,"VERIFY",6);l(this,"START_APP",7);l(this,"EXIT",8);l(this,"ACK",9);l(this,"DATA",16);l(this,"FOR_WRITE",17);l(this,"FOR_READ",34);l(this,"OK",1);l(this,"FAIL",0);l(this,"flash_start_addr",0);l(this,"page_size",2048);l(this,"ROM_INVALID_RECV_MSG",5);this.port=e}static mdebug(e,t,i=`
`){{const n=document.querySelector("#console");n.value+=t+`
`,n.scrollTop=n.scrollHeight}}_shortToBytearray(e){return new Uint8Array([e&255,e>>8&255])}_intToByteArray(e){return new Uint8Array([e&255,e>>8&255,e>>16&255,e>>24&255])}_byteArrayToShort(e,t){return e|t>>8}_byteArrayToInt(e,t,i,n){return e|t<<8|i<<16|n<<24}async flushInput(){try{await this.rawRead(200)}catch(e){console.error(e.message)}}async readPacket(e=null,t=3e3){for(let i=0;i<100;i++){const n=await this.read(t),a=n[0],s=n[1],c=this._byteArrayToInt(n[4],n[5],n[6],n[7]),u=n.slice(8);if(a==1){if(e==null||s==e)return[c,u];if(u[0]!=0&&u[1]==this.ROM_INVALID_RECV_MSG)throw await this.flushInput(),new Error("unsupported command error")}}throw new Error("invalid response")}async command(e=null,t=new Uint8Array(0),i=0,n=!0,a=3e3){if(e!=null){this.tracing&&this.trace(`command op:0x${e.toString(16).padStart(2,"0")} data len=${t.length} wait_response=${n?1:0} timeout=${(a/1e3).toFixed(3)} data=${this.hexConvert(t)}`);const s=new Uint8Array(8+t.length);s[0]=0,s[1]=e,s[2]=this._shortToBytearray(t.length)[0],s[3]=this._shortToBytearray(t.length)[1],s[4]=this._intToByteArray(i)[0],s[5]=this._intToByteArray(i)[1],s[6]=this._intToByteArray(i)[2],s[7]=this._intToByteArray(i)[3];let c;for(c=0;c<t.length;c++)s[8+c]=t[c];await this.write(s)}return n?this.readPacket(e,a):[0,new Uint8Array(0)]}async checkCommand(e="",t=null,i=new Uint8Array(0),n=0,a=3e3){console.log("check_command "+e);const s=await this.command(t,i,n,void 0,a);return s[1].length>4?s[1]:s[0]}async readSer(e=1){return await this.read(10,e)}async erase(){this.BSL||await this.BSLInit();const e=this.frameToSerial(this.FOR_WRITE,this.ERASE,new Uint8Array,0);for(await this.write(e),console.log(5,"performing mass erase",e);;){const t=await this.readSer(this.MAX_BUFF_LEN);if(console.log(t,"frame is"),t.length){const i=this.dataFromSerial(t);if(!i){await this.sleep(100);continue}const[n,a]=i;if(n===this.ACK&&a.includes(this.OK)){d.mdebug(5,"Erase done");break}else if(n===this.ACK&&a.includes(this.FAIL))throw new Error("Erase Failed")}else d.mdebug(5,"erase: no data from serial");await this.sleep(100)}}async BSLInit(){d.mdebug(5,"BSLInit");const e=this.frameToSerial(this.FOR_WRITE,this.START,new Uint8Array,0);for(console.log("BSLInit frame",e),await this.write(e);!this.BSL;){const t=await this.readSer();if(t.length){const i=this.dataFromSerial(t);if(console.log("BSLInit frame",i,t),!i){d.mdebug(5,"BSLInit: no data from serial",i),await this.sleep(100);continue}const[n,a]=i;if(n===this.ACK&&a.includes(this.OK)){this.BSL=!0,d.mdebug(5,"Bootloader active");break}else if(n===this.ACK&&a.includes(this.FAIL))throw new Error("BSLInit Failed")}else d.mdebug(5,"BSLInit: no data from serial");await this.sleep(100)}}async startApp(){if(!this.BSL)throw new Error("Not in BSL mode");const e=this.frameToSerial(this.FOR_WRITE,this.START_APP,new Uint8Array,0);for(await this.write(e);;){const t=await this.readSer(this.MAX_BUFF_LEN);if(console.log("startApp frame",t),t.length){const i=this.dataFromSerial(t);if(!i){await this.sleep(100);continue}const[n,a]=i;if(n===this.ACK&&a.includes(this.OK)){d.mdebug(5,"Start App done");break}else if(n===this.ACK&&a.includes(this.FAIL))throw new Error("Start App Failed")}else d.mdebug(5,"startApp: no data from serial");await this.sleep(100)}}async writeDataInChunks(e){for(let i=0;i<e.length;i+=64){const n=e.slice(i,i+64);await this.write(n),await this.sleep(1e3)}}crc32(e){this._crc32=4294967295;for(const t of e){this._crc32^=t;for(let i=0;i<8;i++){const n=-(this._crc32&1);this._crc32=this._crc32>>>1^this.CRC32_POLY&n}}return this._crc32>>>0}async verify(e,t,i){let n=this.crc32(i);const a=new Uint8Array([n>>24&255,n>>8&255,n&255,e>>24&255,e>>16&255,e>>8&255,e&255,t>>24&255,t>>16&255,t>>8&255,t&255]),s=this.frameToSerial(this.FOR_WRITE,this.VERIFY,a,12);for(await this.write(s);;){const c=await this.readSer(this.MAX_BUFF_LEN);if(console.log("readMemory frame",c),c.length){const u=this.dataFromSerial(c);if(!u){await this.sleep(100);continue}const[g,p]=u;if(g===this.ACK&&p.includes(this.OK)){d.mdebug(5,"verification done"),await this.startApp();break}else if(g===this.ACK&&p.includes(this.FAIL))throw new Error("verification Failed")}else d.mdebug(5,"ReadMemory: no data from serial");await this.sleep(100)}}async writeMemory(e,t){if(!this.BSL)throw new Error("Not in BSL mode");const i=t.length;console.log("length",i);const n=new Uint8Array([e>>24&255,e>>16&255,e>>8&255,e&255,i>>24&255,i>>16&255,i>>8&255,i&255]),a=this.frameToSerial(this.FOR_WRITE,this.WRITE,n,8);for(console.log("writeMemory frame",a),await this.write(a),await this.writeChunk(t,64);;){const s=await this.readSer(this.MAX_BUFF_LEN);if(console.log("readMemory frame",s),s.length){const c=this.dataFromSerial(s);if(!c){await this.sleep(100);continue}const[u,g]=c;if(u===this.ACK&&g.includes(this.OK)){d.mdebug(5,"write done"),await this.startApp();break}else if(u===this.ACK&&g.includes(this.FAIL))throw new Error("write Failed")}else d.mdebug(5,"ReadMemory: no data from serial");await this.sleep(100)}}intelHexToUint8Array(e){const t=e.trim().split(`
`),i=[];return t.forEach(n=>{if(n.startsWith(":")){const a=parseInt(n.substr(1,2),16),s=9,c=s+a*2;for(let u=s;u<c;u+=2)i.push(parseInt(n.substr(u,2),16))}}),new Uint8Array(i)}async writeFlash(e){this.BSL||await this.BSLInit();const t=this.intelHexToUint8Array(e);await this.erase(),await this.writeMemory(this.flash_start_addr,t);const i=this.frameToSerial(this.FOR_WRITE,this.EXIT,new Uint8Array,0);console.log("exiting",i)}async verifyFlash(e){this.BSL||await this.BSLInit();const t=this.intelHexToUint8Array(e);await this.verify(this.flash_start_addr,t.length,t)}};l(d,"QUIET",5);let h=d,w=!1,f,y;const S=[{usbVendorId:12346,usbProductId:4097}];function T(o){o.addEventListener("click",()=>{if(w&&f){f.disconnect(),o.innerHTML="Connect",w=!1;return}o.innerHTML="Connecting...",navigator.serial.requestPort({filters:S}).then(async r=>{f=await new h(r),await f.connect(),o.innerHTML="Connected",h.mdebug(1,"Device Connected"),w=!0}).catch(r=>{console.error(r),h.mdebug(1,"Error Connecting"),f.disconnect(),o.innerHTML="Connect",w=!1})})}function v(o){o.addEventListener("click",async()=>{if(!w){h.mdebug(1,"Please Connect First");return}o.innerHTML="Erasing...";try{await f.erase()}catch(r){console.log(r),h.mdebug(1,"Error Erasing")}o.innerHTML="Erase"})}function E(o){o.addEventListener("click",async()=>{if(!w){h.mdebug(1,"Please Connect First");return}if(!y){h.mdebug(1,"Please upload a .Hex file first");return}o.innerHTML="Verifying...";try{await f.verifyFlash(y)}catch(r){console.log(r),h.mdebug(1,"Error Verifying")}o.innerHTML="Verify"})}function L(o){o.addEventListener("click",async()=>{if(!w){h.mdebug(1,"Please Connect First");return}if(!y){h.mdebug(1,"Please upload a .Hex file first");return}o.innerHTML="Flashing...";try{await f.writeFlash(y),h.mdebug(1,"Flashing Done")}catch(r){console.log(r),h.mdebug(1,"Error Flashing")}o.innerHTML="Flash"})}function R(o){return new Promise((r,e)=>{const t=new FileReader;t.onload=()=>r(t.result),t.onerror=e,t.readAsText(o)})}function F(o){o.addEventListener("change",async r=>{y="";const e=r.target.files[0];e&&e.name.endsWith(".hex")?(y=await R(e),console.log(y)):h.mdebug(1,"Please upload a valid .hex file")})}function I(o){o.addEventListener("click",async()=>{if(!w){h.mdebug(1,"Please Connect First");return}o.innerHTML="Resting...",await f.startApp(),o.innerHTML="Reset"})}document.querySelector("#app").innerHTML=`
  <div>
    <h1>MSPMO Flasher via ESP</h1>
    <h4>Supported Browsers: Chrome, Edge</h4>
    <button id="connect" type="button">Connect</button
      <input type="file" id="myfile" name="myfile" accept=".hex">
      <input type="file" id="myfile" name="myfile"><br><br>
      <button id="erase" type="button">Erase</button>
      <button id="flash" type="button">Flash</button>
      <button id="verify" type="button">Verify</button>
      <button id="reset" type="button">Reset</button>
      <textarea id="console" rows="15" cols="50" readonly></textarea>
  </div>
`;T(document.querySelector("#connect"));v(document.querySelector("#erase"));L(document.querySelector("#flash"));F(document.querySelector("#myfile"));I(document.querySelector("#reset"));E(document.querySelector("#verify"));
