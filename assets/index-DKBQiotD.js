var y=Object.defineProperty;var g=(l,t,e)=>t in l?y(l,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):l[t]=e;var o=(l,t,e)=>g(l,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const a of n.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function e(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function r(i){if(i.ep)return;i.ep=!0;const n=e(i);fetch(i.href,n)}})();class p{constructor(t,e=!0,r=!1){o(this,"slipReaderEnabled",!1);o(this,"leftOver",new Uint8Array(0));o(this,"baudrate",115200);o(this,"traceLog","");o(this,"lastTraceTime",Date.now());o(this,"reader");o(this,"checksum",function(t){let e,r=239;for(e=0;e<t.length;e++)r^=t[e];return r});this.device=t,this.tracing=e,this.slipReaderEnabled=r,this.getInfo()}getInfo(){const t=this.device.getInfo();return console.log("Product info",t),t.usbVendorId&&t.usbProductId}async sleep(t){return new Promise(e=>setTimeout(e,t))}async waitForUnlock(t){for(;this.device.readable&&this.device.readable.locked||this.device.writable&&this.device.writable.locked;)await this.sleep(t)}async connect(t=115200){try{await this.device.open({baudRate:t,bufferSize:1024}),this.baudrate=t,this.leftOver=new Uint8Array(0),console.log("Connected to device")}catch(e){console.error("Error in connect",e)}}async disconnect(){var t,e;(t=this.device.readable)!=null&&t.locked&&await((e=this.reader)==null?void 0:e.cancel()),await this.waitForUnlock(400),this.reader=void 0,await this.device.close()}trace(t){const i=`${`TRACE ${(Date.now()-this.lastTraceTime).toFixed(3)}`} ${t}`;console.log(i),this.traceLog+=i+`
`}hexify(t){return Array.from(t).map(e=>e.toString(16).padStart(2,"0")).join("").padEnd(16," ")}hexConvert(t,e=!0){if(e&&t.length>16){let r="",i=t;for(;i.length>0;){const n=i.slice(0,16),a=String.fromCharCode(...n).split("").map(s=>s===" "||s>=" "&&s<="~"&&s!=="  "?s:".").join("");i=i.slice(16),r+=`
    ${this.hexify(n.slice(0,8))} ${this.hexify(n.slice(8))} | ${a}`}return r}else return this.hexify(t)}async returnTrace(){try{await navigator.clipboard.writeText(this.traceLog),console.log("Text copied to clipboard!")}catch(t){console.error("Failed to copy text:",t)}}_appendBuffer(t,e){const r=new Uint8Array(t.byteLength+e.byteLength);return r.set(new Uint8Array(t),0),r.set(new Uint8Array(e),t.byteLength),r.buffer}slipWriter(t){const e=new Array;e.push(192);for(let r=0;r<t.length;r++)t[r]===219?e.push(219,221):t[r]===192?e.push(219,220):e.push(t[r]);return e.push(192),new Uint8Array(e)}async writeChunk(t,e){let r=0;if(this.device.writable){const i=this.device.writable.getWriter();for(;r<t.length;){const n=t.slice(r,r+e);await i.write(n),console.log("Write chunk",n),r+=e}i.releaseLock()}}async write(t){const e=this.slipReaderEnabled?this.slipWriter(t):t;if(this.device.writable){const r=this.device.writable.getWriter();this.tracing&&(console.log("Write bytes"),this.trace(`Write ${e.length} bytes: ${this.hexConvert(e)}`)),await r.write(e),console.log("Write bytes",e),r.releaseLock()}}slipReader(t){let e=0,r=0,i=0,n="init";for(;e<t.length;){if(n==="init"&&t[e]==192){r=e+1,n="valid_data",e++;continue}if(n==="valid_data"&&t[e]==192){i=e-1,n="packet_complete";break}e++}if(n!=="packet_complete")return this.leftOver=t,new Uint8Array(0);this.leftOver=t.slice(i+2);const a=new Uint8Array(i-r+1);let s=0;for(e=r;e<=i;e++,s++){if(t[e]===219&&t[e+1]===220){a[s]=192,e++;continue}if(t[e]===219&&t[e+1]===221){a[s]=219,e++;continue}a[s]=t[e]}return a.slice(0,s)}async read(t=0,e=12){let r,i=this.leftOver;if(this.leftOver=new Uint8Array(0),this.slipReaderEnabled){const n=this.slipReader(i);if(n.length>0)return n;i=this.leftOver,this.leftOver=new Uint8Array(0)}if(this.device.readable==null)return this.leftOver;this.reader=this.device.readable.getReader();try{t>0&&(r=setTimeout(()=>{this.reader&&this.reader.cancel()},t));do{if(!this.reader)throw new Error("Reader is undefined");const{value:n,done:a}=await this.reader.read();if(a&&(this.leftOver=i,console.log("Timeout")),!n)break;i=new Uint8Array(this._appendBuffer(i.buffer,n.buffer))}while(i.length<e)}finally{if(t>0&&clearTimeout(r),!this.reader)throw new Error("Reader is undefined");this.reader.releaseLock()}if(this.tracing&&(console.log("Read bytes"),this.trace(`Read ${i.length} bytes: ${this.hexConvert(i)}`)),this.slipReaderEnabled){const n=this.slipReader(i);return this.tracing&&(console.log("Slip reader results"),this.trace(`Read ${n.length} bytes: ${this.hexConvert(n)}`)),n}return i}async rawRead(t=0){if(this.leftOver.length!=0){const r=this.leftOver;return this.leftOver=new Uint8Array(0),r}if(!this.device.readable)return this.leftOver;this.reader=this.device.readable.getReader();let e;try{if(t>0&&(e=setTimeout(()=>{this.reader&&this.reader.cancel()},t)),!this.reader)throw new Error("Reader is undefined");const{value:r,done:i}=await this.reader.read();return i?r||new Uint8Array(0):(this.tracing&&(console.log("Raw Read bytes"),this.trace(`Read ${r.length} bytes: ${this.hexConvert(r)}`)),r)}finally{if(t>0&&clearTimeout(e),!this.reader)throw new Error("Reader is undefined");this.reader.releaseLock()}}checkSum(t,e){let r=0;console.log("buf",e);for(let i=2;i<e-1;i++)r+=t[i];return r=r&255,r=~r&255,r}frameToSerial(t,e,r,i){const n=i+9,a=i+2,s=new Uint8Array(n);return s[0]=249,s[1]=255,s[2]=a>>24&255,s[3]=a>>16&255,s[4]=a>>8&255,s[5]=a&255,s[6]=t,s[7]=e,s.set(r,8),s[s.length-1]=this.checkSum(s,s.length-1),s}dataFromSerial(t){const e=this.checkSum(t,t.length);return console.log("CKSM",e,t),t[0]!==249||t[1]!==245||t[t.length-1]!==e?(console.log("Invalid frame"),null):[t[7],t.subarray(8,t.length)]}}class m extends p{constructor(e){super(e);o(this,"QUIET",5);o(this,"DEFAULT_BAUD",115200);o(this,"MAX_BUFF_LEN",64);o(this,"SETUP",!1);o(this,"BSL",!1);o(this,"CRC32_POLY",3988292384);o(this,"START",1);o(this,"ERASE",2);o(this,"PAGE_ERASE",3);o(this,"WRITE",4);o(this,"READ",5);o(this,"VERIFY",6);o(this,"START_APP",7);o(this,"EXIT",8);o(this,"ACK",9);o(this,"DATA",16);o(this,"FOR_WRITE",17);o(this,"FOR_READ",34);o(this,"OK",1);o(this,"FAIL",0);o(this,"flash_start_addr",0);o(this,"page_size",2048);o(this,"ROM_INVALID_RECV_MSG",5);this.port=e}mdebug(e,r,i=`
`){this.QUIET>=e&&console.log(r+i)}_shortToBytearray(e){return new Uint8Array([e&255,e>>8&255])}_intToByteArray(e){return new Uint8Array([e&255,e>>8&255,e>>16&255,e>>24&255])}_byteArrayToShort(e,r){return e|r>>8}_byteArrayToInt(e,r,i,n){return e|r<<8|i<<16|n<<24}async flushInput(){try{await this.rawRead(200)}catch(e){console.error(e.message)}}async readPacket(e=null,r=3e3){for(let i=0;i<100;i++){const n=await this.read(r),a=n[0],s=n[1],c=this._byteArrayToInt(n[4],n[5],n[6],n[7]),h=n.slice(8);if(a==1){if(e==null||s==e)return[c,h];if(h[0]!=0&&h[1]==this.ROM_INVALID_RECV_MSG)throw await this.flushInput(),new Error("unsupported command error")}}throw new Error("invalid response")}async command(e=null,r=new Uint8Array(0),i=0,n=!0,a=3e3){if(e!=null){this.tracing&&this.trace(`command op:0x${e.toString(16).padStart(2,"0")} data len=${r.length} wait_response=${n?1:0} timeout=${(a/1e3).toFixed(3)} data=${this.hexConvert(r)}`);const s=new Uint8Array(8+r.length);s[0]=0,s[1]=e,s[2]=this._shortToBytearray(r.length)[0],s[3]=this._shortToBytearray(r.length)[1],s[4]=this._intToByteArray(i)[0],s[5]=this._intToByteArray(i)[1],s[6]=this._intToByteArray(i)[2],s[7]=this._intToByteArray(i)[3];let c;for(c=0;c<r.length;c++)s[8+c]=r[c];await this.write(s)}return n?this.readPacket(e,a):[0,new Uint8Array(0)]}async checkCommand(e="",r=null,i=new Uint8Array(0),n=0,a=3e3){console.log("check_command "+e);const s=await this.command(r,i,n,void 0,a);return s[1].length>4?s[1]:s[0]}async readSer(e=1){return await this.read(10,e)}async erase(){if(!this.BSL)throw new Error("Not in BSL mode");const e=this.frameToSerial(this.FOR_WRITE,this.ERASE,new Uint8Array,0);for(await this.write(e),console.log(5,"performing mass erase",e);;){const r=await this.readSer(this.MAX_BUFF_LEN);if(console.log(r,"frame is"),r.length){const i=this.dataFromSerial(r);if(!i){debugger;await this.sleep(100);continue}const[n,a]=i;if(n===this.ACK&&a.includes(this.OK)){this.mdebug(5,"Erase done");break}else if(n===this.ACK&&a.includes(this.FAIL))throw new Error("Erase Failed")}else this.mdebug(5,"erase: no data from serial");await this.sleep(100)}}async BSLInit(){this.mdebug(5,"BSLInit");const e=this.frameToSerial(this.FOR_WRITE,this.START,new Uint8Array,0);for(console.log("BSLInit frame",e),await this.write(e);!this.BSL;){const r=await this.readSer();if(r.length){const i=this.dataFromSerial(r);if(console.log("BSLInit frame",i,r),!i){this.mdebug(5,"BSLInit: no data from serial",i),await this.sleep(100);continue}const[n,a]=i;if(n===this.ACK&&a.includes(this.OK)){this.BSL=!0,this.mdebug(5,"Bootloader active");break}else if(n===this.ACK&&a.includes(this.FAIL))throw new Error("BSLInit Failed")}else this.mdebug(5,"BSLInit: no data from serial");await this.sleep(100)}}async startApp(){if(!this.BSL)throw new Error("Not in BSL mode");const e=this.frameToSerial(this.FOR_WRITE,this.START_APP,new Uint8Array,0);for(await this.write(e);;){const r=await this.readSer(this.MAX_BUFF_LEN);if(console.log("startApp frame",r),r.length){const i=this.dataFromSerial(r);if(!i){await this.sleep(100);continue}const[n,a]=i;if(n===this.ACK&&a.includes(this.OK)){this.mdebug(5,"Start App done");break}else if(n===this.ACK&&a.includes(this.FAIL))throw new Error("Start App Failed")}else this.mdebug(5,"startApp: no data from serial");await this.sleep(100)}}async writeDataInChunks(e){for(let i=0;i<e.length;i+=64){const n=e.slice(i,i+64);await this.write(n),await this.sleep(1e3)}}async writeMemory(e,r){if(!this.BSL)throw new Error("Not in BSL mode");const i=r.length;console.log("length",i);const n=new Uint8Array([e>>24&255,e>>16&255,e>>8&255,e&255,i>>24&255,i>>16&255,i>>8&255,i&255]),a=this.frameToSerial(this.FOR_WRITE,this.WRITE,n,8);for(console.log("writeMemory frame",a),await this.write(a),await this.writeChunk(r,64);;){const s=await this.readSer(this.MAX_BUFF_LEN);if(console.log("readMemory frame",s),s.length){const c=this.dataFromSerial(s);if(!c){await this.sleep(100);continue}const[h,w]=c;if(h===this.ACK&&w.includes(this.OK)){this.mdebug(5,"write done"),await this.startApp();break}else if(h===this.ACK&&w.includes(this.FAIL))throw new Error("write Failed")}else this.mdebug(5,"ReadMemory: no data from serial");await this.sleep(100)}}intelHexToUint8Array(e){const r=e.trim().split(`
`),i=[];return r.forEach(n=>{if(n.startsWith(":")){const a=parseInt(n.substr(1,2),16),s=9,c=s+a*2;for(let h=s;h<c;h+=2)i.push(parseInt(n.substr(h,2),16))}}),new Uint8Array(i)}async writeFlash(e){if(!this.BSL)throw new Error("Not in BSL mode");const r=this.intelHexToUint8Array(e);await this.erase(),await this.writeMemory(this.flash_start_addr,r);const i=this.frameToSerial(this.FOR_WRITE,this.EXIT,new Uint8Array,0);console.log("exiting",i)}}let u=!1,d,f;const A=[{usbVendorId:12346,usbProductId:4097}];function b(l){l.addEventListener("click",()=>{if(u&&d){d.disconnect(),l.innerHTML="Connect",u=!1;return}l.innerHTML="Connecting...",navigator.serial.requestPort({filters:A}).then(async t=>{d=await new m(t),await d.connect(),await d.BSLInit(),l.innerHTML="Connected",u=!0}).catch(t=>{console.error(t),alert("Error Connecting"),d.disconnect(),l.innerHTML="Connect",u=!1})})}function S(l){l.addEventListener("click",async()=>{if(!u){alert("Please Connect First");return}l.innerHTML="Erasing...";try{await d.erase(),alert("Erase Done")}catch(t){console.log(t),alert("Error Erasing")}l.innerHTML="Erase"})}function E(l){l.addEventListener("click",async()=>{if(!u){alert("Please Connect First");return}if(!f){alert("Please upload a .Hex file first");return}l.innerHTML="Flashing...";try{await d.writeFlash(f),alert("Flashing Done")}catch(t){console.log(t),alert("Error Flashing")}l.innerHTML="Flash"})}function T(l){return new Promise((t,e)=>{const r=new FileReader;r.onload=()=>t(r.result),r.onerror=e,r.readAsText(l)})}function L(l){l.addEventListener("change",async t=>{const e=t.target.files[0];e&&e.name.endsWith(".hex")?(f=await T(e),console.log(f)):alert("Please upload a valid .hex file")})}function v(l){l.addEventListener("click",async()=>{if(!u){alert("Please Connect First");return}l.innerHTML="Resting...",await d.startApp(),l.innerHTML="Reset"})}document.querySelector("#app").innerHTML=`
  <div>
    <h1>Port11 MSPMO Flasher</h1>
    <h2>Supported only with Chrome Browser</h2>
    <button id="connect" type="button">Connect</button
      <input type="file" id="myfile" name="myfile" accept=".hex">
      <input type="file" id="myfile" name="myfile"><br><br>
      <button id="erase" type="button">Erase</button>
      <button id="flash" type="button">Flash</button>
      <button id="reset" type="button">Reset</button>
  </div>
`;b(document.querySelector("#connect"));S(document.querySelector("#erase"));E(document.querySelector("#flash"));L(document.querySelector("#myfile"));v(document.querySelector("#reset"));
