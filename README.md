# Port11 - MSPM0 Flasher Tool via UART

This tool can be used to FLASH, ERASE, GET_INFO, and VERIFY your MSPM0 via the UART PIN of the MSPM0. Make sure to put the MSPM0 in BSL mode manually before using this tool. Alternatively, you can use another microcontroller to toggle the GPIO of the MSPM0 to put it in BSL mode. This implementation uses an ESP32-S3 as a debugger to pass messages between the MSPM0 and the web client serial. You can find the firmware file in the firmware folder. Use the [ESP32 online Flasher](https://espressif.github.io/esptool-js/) to flash the firmware at address 0x0.

## Support Series

- [x] MSPM0

## Tested Chips

- [x] MSPM0G3507

## Author

[Goutham S Krishna](https://www.linkedin.com/in/goutham-s-krishna-21ab151a0/)

## Get Device Info Frame Walkthrough

The web client discovers the MSPM0 memory layout by issuing TI's `GetDeviceInfo` command as soon as a BSL session is established. The transfer happens in three steps that mirror the code inside `src/flasherV2`.

### 1. Frame construction

`Protocol.getFrameRaw({ type: "GetDeviceInfo" })` builds the exact byte sequence that is written to the ESP32 UART bridge:

```
Uint8Array([128, 1, 0, 25, 178, 184, 150, 73])
```

| Byte(s) | Hex | Meaning |
| --- | --- | --- |
| 0 | `0x80` | Fixed BSL transport header |
| 1-2 | `0x0001` | Little-endian payload length (command only) |
| 3 | `0x19` | `GET_DEVICE_INFO` opcode |
| 4-7 | `0xB2 0xB8 0x96 0x49` | CRC-32 (little-endian) of the single command byte |

The CRC comes from `Protocol.softwareCRC` (polynomial `0xEDB88320`, seed `0xFFFFFFFF`). Because the request carries no payload, the CRC is calculated over `[0x19]` only.

### 2. Receiving and validating the response

`MSPLoaderV2.get_device_info()` waits for a 33-byte reply, runs the buffer through `slipReader` to strip SLIP escapes, and then calls `check_crc` to recompute the CRC across the payload (`frame.slice(4, 3 + length)`). Any mismatch throws `CRC Check Failed`, preventing stale metadata from being used.

### 3. Field extraction

`Protocol.getResponse()` parses the device-information payload. Indexing is relative to the raw frame (`resSlip`):

| Index | Meaning | Notes |
| --- | --- | --- |
| 0 | `0x80` header | transport constant |
| 1-2 | payload length | little-endian byte count |
| 3 | `0x31` (`DEVICE_INFO_RESPONSE`) | identifies the response type |
| 4 | Reserved/status byte | echoed from the target (TI docs list this as reserved) |
| 5 | General status (`BSL_ACK` = `0x00`) | also becomes the little-endian LSB for the next 16-bit field |
| 6 | CMD interpreter version MSB | combined with index 5 |
| 7-8 | Build ID (LE) | firmware build number |
| 9-12 | App version (LE) | 32-bit semantic version |
| 13-14 | Active plugin interface version (LE) | protocol compatibility |
| 15-16 | BSL max buffer size (LE) | stored in `FLASH_MAX_BUFFER_SIZE` |
| 17-20 | BSL buffer start address (LE) | saved to `FLASH_START_ADDRESS` |
| 21-24 | BCR config ID (LE) | board configuration register |
| 25-28 | BSL config ID (LE) | bootloader configuration |
| 29-32 | CRC-32 (LSB → MSB) | integrity check |

The implementation treats all multi-byte quantities as little-endian. For example, the flash buffer base address is reconstructed as

```
BSL_buffer_start_address =
	(data[20] << 24) |
	(data[19] << 16) |
	(data[18] << 8)  |
	data[17];
```

which is then copied into `MSPLoaderV2.FLASH_START_ADDRESS`. The same pattern is used for `BSL_max_buffer_size`, `BCR_config_id`, and `BSL_config_id`. Because the general-status byte is `0x00` on success, it doubles as the low byte of the interpreter-version field without affecting the parsed value.

## Other Control Frames

Each command uses the same outer frame: `0x80` header, 16-bit little-endian payload length, opcode + arguments, followed by a CRC-32 (`0xEDB88320`, seed `0xFFFFFFFF`) in little-endian order. Below are the concrete payload layouts generated by `Protocol.getFrameRaw`.

### Connection Handshake

```
Uint8Array([128, 1, 0, 18, 58, 97, 68, 222])
```

| Byte(s) | Hex | Meaning |
| --- | --- | --- |
| 0 | `0x80` | Transport header |
| 1-2 | `0x0001` | Payload length |
| 3 | `0x12` | `CONNECTION` opcode |
| 4-7 | `0x3A 0x61 0x44 0xDE` | CRC of `[0x12]` |

The ROM replies with a 6-byte frame. `Protocol.getResponse()` inspects index 5 (`BSL_ACK` on success) before any further commands run.

### Unlock Bootloader (Default Password)

```
Uint8Array([
	128, 33, 0, 33,
	255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255,
	2, 170, 240, 61,
])
```

| Byte(s) | Hex | Meaning |
| --- | --- | --- |
| 0 | `0x80` | Transport header |
| 1-2 | `0x0021` | 33-byte payload (opcode + 32-byte password) |
| 3 | `0x21` | `UNLOCK_BOOTLOADER` opcode |
| 4-35 | `0xFF × 32` | Default erased password payload |
| 36-39 | `0x02 0xAA 0xF0 0x3D` | CRC of the 33 payload bytes |

The response repeats the opcode (`0x21`) at index 3 and returns status in index 5. Any non-ACK triggers the "Bootloader Unlock Failed" error path.

### Mass Erase

```
Uint8Array([128, 1, 0, 21, 153, 244, 32, 64])
```

| Byte(s) | Hex | Meaning |
| --- | --- | --- |
| 0 | `0x80` | Transport header |
| 1-2 | `0x0001` | Payload length |
| 3 | `0x15` | `MASS_ERASE` opcode |
| 4-7 | `0x99 0xF4 0x20 0x40` | CRC of `[0x15]` |

`MSPLoaderV2.mass_earse()` waits for a 10-byte response, confirming ACK and updating the OLED helper.

### Program Data (example chunk)

Example: write 16 bytes starting at `0x00000000` (data `0x00` through `0x0F`).

```
Uint8Array([
	128, 21, 0, 32,
	0, 0, 0, 0, // start address LSB → MSB
	0, 1, 2, 3, 4, 5, 6, 7,
	8, 9, 10, 11, 12, 13, 14, 15,
	113, 182, 70, 11,
])
```

| Byte(s) | Hex | Meaning |
| --- | --- | --- |
| 0 | `0x80` | Transport header |
| 1-2 | `0x0015` | Payload length (`1 + 4 + 16`) |
| 3 | `0x20` | `PROGRAM_DATA` opcode |
| 4-7 | `0x00 0x00 0x00 0x00` | Start address (little-endian in this payload) |
| 8-23 | `0x00` → `0x0F` | Data chunk to program |
| 24-27 | `0x71 0xB6 0x46 0x0B` | CRC over opcode + address + data |

Acknowledge frames return the opcode (`0x20`) at index 3 and the status at index 5. On success, the loader advances the start address by the payload size and continues streaming.

### Memory Read (example request)

Request 16 bytes at address `0x00001000` with a transfer-length argument of `0x00000010`:

```
Uint8Array([
	128, 9, 0, 41,
	0, 0, 16, 0, // start address MSB → LSB (per TI spec)
	16, 0, 0, 0, // byte count argument
	173, 138, 107, 100,
])
```

| Byte(s) | Hex | Meaning |
| --- | --- | --- |
| 0 | `0x80` | Transport header |
| 1-2 | `0x0009` | Payload length (`1 + 4 + 4`) |
| 3 | `0x29` | `MEMORY_READ` opcode |
| 4-7 | `0x00 0x00 0x10 0x00` | Start address (big-endian inside the 4-byte field) |
| 8-11 | `0x10 0x00 0x00 0x00` | Read length argument (little-endian) |
| 12-15 | `0xAD 0x8A 0x6B 0x64` | CRC over opcode + address + length |

The device responds with frame type `0x30` (`MEMORY_READ_RESPONSE`). `Protocol.getResponse()` collects the raw payload bytes, which the caller can render or store.

### Start Application

```
Uint8Array([128, 1, 0, 64, 10, 77, 86, 102])
```

| Byte(s) | Hex | Meaning |
| --- | --- | --- |
| 0 | `0x80` | Transport header |
| 1-2 | `0x0001` | Payload length |
| 3 | `0x40` | `START_APP` opcode |
| 4-7 | `0x0A 0x4D 0x56 0x66` | CRC of `[0x40]` |

On ACK, `MSPLoaderV2.start_app()` clears the `conn_established` flag and returns control to the user application.
